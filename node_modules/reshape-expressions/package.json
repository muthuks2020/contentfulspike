{
  "_args": [
    [
      {
        "raw": "reshape-expressions@^0.1.5",
        "scope": null,
        "escapedName": "reshape-expressions",
        "name": "reshape-expressions",
        "rawSpec": "^0.1.5",
        "spec": ">=0.1.5 <0.2.0",
        "type": "range"
      },
      "/home/muthu/try/spiket/node_modules/reshape-standard"
    ]
  ],
  "_from": "reshape-expressions@>=0.1.5 <0.2.0",
  "_id": "reshape-expressions@0.1.5",
  "_inCache": true,
  "_location": "/reshape-expressions",
  "_nodeVersion": "7.5.0",
  "_npmOperationalInternal": {
    "host": "packages-18-east.internal.npmjs.com",
    "tmp": "tmp/reshape-expressions-0.1.5.tgz_1487348820598_0.043214083882048726"
  },
  "_npmUser": {
    "name": "jescalan",
    "email": "npm.je@mailhero.io"
  },
  "_npmVersion": "4.1.2",
  "_phantomChildren": {},
  "_requested": {
    "raw": "reshape-expressions@^0.1.5",
    "scope": null,
    "escapedName": "reshape-expressions",
    "name": "reshape-expressions",
    "rawSpec": "^0.1.5",
    "spec": ">=0.1.5 <0.2.0",
    "type": "range"
  },
  "_requiredBy": [
    "/reshape-minify",
    "/reshape-standard"
  ],
  "_resolved": "https://registry.npmjs.org/reshape-expressions/-/reshape-expressions-0.1.5.tgz",
  "_shasum": "28c12bf35de40263362499cead0b044321e4a78c",
  "_shrinkwrap": null,
  "_spec": "reshape-expressions@^0.1.5",
  "_where": "/home/muthu/try/spiket/node_modules/reshape-standard",
  "author": {
    "name": "Jeff Escalante"
  },
  "ava": {
    "verbose": "true",
    "serial": "true"
  },
  "bugs": {
    "url": "https://github.com/reshape/expressions/issues"
  },
  "dependencies": {},
  "description": "local variables, expressions, loops, and conditionals",
  "devDependencies": {
    "ava": "^0.18.1",
    "coveralls": "^2.11.16",
    "nyc": "^10.1.2",
    "reshape": "^0.4.1",
    "snazzy": "^6.0.0",
    "standard": "^8.6.0"
  },
  "directories": {},
  "dist": {
    "shasum": "28c12bf35de40263362499cead0b044321e4a78c",
    "tarball": "https://registry.npmjs.org/reshape-expressions/-/reshape-expressions-0.1.5.tgz"
  },
  "engines": {
    "node": ">=6"
  },
  "gitHead": "42d30c2b62acd6bc576335268b17e0bbcfc1d210",
  "homepage": "https://github.com/reshape/expressions",
  "keywords": [
    "conditionals",
    "expressions",
    "loops",
    "reshape-plugin"
  ],
  "license": "MIT",
  "main": "lib",
  "maintainers": [
    {
      "name": "jescalan",
      "email": "npm.je@mailhero.io"
    }
  ],
  "name": "reshape-expressions",
  "optionalDependencies": {},
  "readme": "# Reshape Expressions\n\n[![npm](https://img.shields.io/npm/v/reshape-expressions.svg?style=flat-square)](https://npmjs.com/package/reshape-expressions)\n[![tests](https://img.shields.io/travis/reshape/expressions.svg?style=flat-square)](https://travis-ci.org/reshape/expressions?branch=master)\n[![dependencies](https://img.shields.io/david/reshape/expressions.svg?style=flat-square)](https://david-dm.org/reshape/expressions)\n[![coverage](https://img.shields.io/coveralls/reshape/expressions.svg?style=flat-square)](https://coveralls.io/r/reshape/expressions?branch=master)\n\nLocal variables, expressions, loops, and conditionals in your html.\n\n## Installation\n\nFirst, install from npm with `npm i reshape-exp --save`, then add it as a plugin to your reshape pipeline:\n\n```js\nconst reshape = require('reshape')\nconst exp = require('reshape-expressions')\nconst {readFileSync} = require('fs')\n\nreshape({ plugins: exp() })\n  .process(readFileSync('exampleFile.html', 'utf8'))\n  .then((res) => {\n    return res.output({ foo: 'bar' }) // => your html\n  })\n```\n\n## Usage\n\nThis plugin provides a syntax for including local variables and expressions in your templates, and also extends custom tags to act as helpers for conditionals and looping.\n\nYou have full control over the delimiters used for injecting locals, as well as the tag names for the conditional and loop helpers, if you need them. All options that can be passed to the `expressions` plugin are shown below:\n\n| Option | Description | Default |\n| ------ | ----------- | ------- |\n| **delimiters** | Array containing beginning and ending delimiters for escaped locals. | `['{{', '}}']` |\n| **unescapeDelimiters** | Array containing beginning and ending delimiters for inserting unescaped locals. | `['{{{', '}}}']` |\n| **conditionalTags** | Array containing names for tags used for standard `if`/`else if`/`else` logic | `['if', 'elseif', 'else']` |\n| **loopTags** | Array containing names for standard `for` loop logic | `['each']` |\n\n### Locals\n\nYou can inject locals into any piece of content in your html templates, other than overwriting tag names. For example, if you had the following template:\n\n```html\n<div class=\"{{ myClassName }}\">\n  My name is {{ myName }}\n</div>\n```\n\nAnd passed it through reshape like this:\n\n```js\nreshape({ plugins: exp() })\n  .process(template)\n  .then((res) => res.output({ myClassName: 'introduction', myName: 'Marlo' })))\n```\n\nYou would get this as your output:\n\n```html\n<div class=\"introduction\">My name is Marlo</div>\n```\n\n### Unescaped Locals\n\nBy default, special characters will be escaped so that they show up as text, rather than html code. For example, the following template:\n\n```html\n<p>The fox said, {{ strongStatement }}</p>\n```\n\nCalled as such:\n\n```js\nreshape({ plugins: exp() })\n  .process(template)\n  .then((res) => res.output({ strongStatement: 'wow!' }))\n```\n\nYou would see the following output:\n\n```html\n<p>The fox said, &lt;strong&gt;wow!&lt;strong&gt;</p>\n```\n\nIn your browser, you would see the angle brackets, and it would appear as intended. However, if you wanted it instead to be parsed as html, you would need to use the `unescapeDelimiters`, which by default are three curly brackets, like this:\n\n```html\n<p>The fox said, {{{ strongStatement }}}</p>\n```\n\nIn this case, your code would render as html:\n\n```html\n<p>The fox said, <strong>wow!<strong></p>\n```\n\n### Expressions\n\nYou are not limited to just directly rendering local variables either, you can include any type of javascript expression and it will be evaluated, with the result rendered. For example:\n\n```html\n<p class=\"{{ env === 'production' ? 'active' : 'hidden' }}\">in production!</p>\n```\n\nWith this in mind, it is strongly recommended to limit the number and complexity of expressions that are run directly in your template. You can always move the logic back to your config file and provide a function to the locals object for a smoother and easier result. For example:\n\n```html\n<p class=\"{{ isProduction(env) }}\">in production!</p>\n```\n\n```js\nreshape({ plugins: exp() })\n  .process(template)\n  .then((res) => {\n    return res.output({\n      production: true\n      isProduction: (env) => {\n        return env === 'production' ? 'active' : 'hidden'\n      }\n    })\n  })\n```\n\n```html\n<p class=\"active\">in production!</p>\n```\n\n### Conditional Logic\n\nConditional logic uses normal html tags, and modifies/replaces them with the results of the logic. If there is any chance of a conflict with other custom tag names, you are welcome to change the tag names this plugin looks for in the options. For example, given the following template:\n\n```html\n<if condition=\"foo === 'bar'\">\n  <p>Foo really is bar! Revolutionary!</p>\n</if>\n<elseif condition=\"foo === 'wow'\">\n  <p>Foo is wow, oh man.</p>\n</elseif>\n<else>\n  <p>Foo is probably just foo in the end.</p>\n</else>\n```\n\nAnd the following config:\n\n```js\nreshape({ plugins: exp() })\n  .process(template)\n  .then((res) => res.output({ foo: 'foo' }))\n```\n\nYour result would be only this:\n\n```html\n<p>Foo is probably just foo in the end.</p>\n```\n\nAnything in the `condition` attribute is evaluated directly as an expression.\n\nIt should be noted that this is slightly cleaner-looking if you are using the [SugarML parser](https://github.com/reshape/sugarml). But then again so is every other part of html.\n\n```sml\nif(condition=\"foo === 'bar'\")\n  p Foo really is bar! Revolutionary!\nelseif(condition=\"foo === 'wow'\")\n  p Foo is wow, oh man.\nelse\n  p Foo is probably just foo in the end.\n```\n\n### Loops\n\nYou can use the `each` tag to build loops. It works with both arrays and objects. For example:\n\nInput:\n\n```html\n<each loop=\"item, index of anArray\">\n  <p>{{ index }}: {{ item }}</p>\n</each>\n```\n\nConfig:\n\n```js\nreshape({ plugins: exp() })\n  .process(template)\n  .then((res) => {\n    return res.output({\n      anArray: ['foo', 'bar'],\n      anObject: { foo: 'bar' }\n    })\n  })\n```\n\nOutput:\n\n```html\n<p>1: foo</p>\n<p>2: bar</p>\n```\n\nAnd an example using an object (note that it uses \"in\" rather than \"of\", in the same way that this would be handled with javascript natively):\n\n```html\n<each loop=\"value, key in anObject\">\n  <p>{{ key }}: {{ value }}</p>\n</each>\n```\n\nOutput:\n\n```html\n<p>foo: bar</p>\n```\n\nThe value of the `loop` attribute is not a pure expression evaluation, and it does have a tiny and simple custom parser. Essentially, it starts with one or more variable declarations, comma-separated, followed by the word `in`, followed by an expression.\n\nSo this would also be fine:\n\n```html\n<each loop=\"item in [1,2,3]\">\n  <p>{{ item }}</p>\n</each>\n```\n\nSo you don't need to declare all the available variables (in this case, the index is skipped), and the expression after `in` doesn't need to be a local variable, it can be any expression.\n\n### License & Contributing\n\n- Licensed under [MIT](LICENSE)\n- See [guidelines for contribution](CONTRIBUTING.md)\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/reshape/expressions.git"
  },
  "scripts": {
    "coverage": "nyc --reporter=html ava && open coverage/index.html",
    "coveralls": "nyc report --reporter=text-lcov | coveralls",
    "lint": "standard | snazzy",
    "test": "npm run lint && nyc ava"
  },
  "version": "0.1.5"
}
